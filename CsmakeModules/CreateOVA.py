# <copyright>
# (c) Copyright 2017 Hewlett Packard Enterprise Development LP
#
# This program is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation, either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
# </copyright>
# <copyright>
# (c) Copyright 2017 Hewlett Packard Enterprise Development LP
#
# This program is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation, either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
# </copyright>
from Csmake.CsmakeModule import CsmakeModule
import datetime
import time
import os.path
import tarfile
import StringIO
import hashlib

class CreateOVA(CsmakeModule):
    """Purpose: To create an ovf/ova out of the provided disk(s)
           NOTE: This module currently generates a specific kind of OVA
                 Only a few basic knobs are available for configuration
                 out of the myriad knobs that could be provided
                 The OS is fixed at Debian 64-bit
                 The advice of the ovf says the disk is the capacity
                 presented in the flags, but the image is already created
           The current active metadata will be used to provide
              product information.
           This module requires the definition of product metadata for use
       Library: csmake-system-build
       Phases: build, clean
       Flags:
           vm-name: The name to give to the virtual machine
           vm-description: A description of the virtual machine
           vm-cpus: Number of cpus to allocate to the vm
           vm-cpu-speed: ++FUTURE++
           vm-memory: Memory to allocate to vm (in MB)
           os: Type of operating system
           os-description: Description of operating system
           manifest-format: (OPTIONAL) sha1 default, sha256 is also available
                            vCenter 6.5 wants sha256.
           disk-format-<intent>: The disk format in the file mappings
                          will map to <intent>
           disk-capacity-<intent>: The intents in the file mappings
                          will map to <intent> (capacity in GB)
               Note: Disks will be flagged 'sparse' so they will
                     not use to their capacity.
               Note Also: This is currently being ignored - technically
                          this should be driven by the image creation and
                          data fed in here.
           add-cd-dvd-rom: True or False; add a CD/DVD ROM drive to the VM
       Maps:
           Expects a 1-1 or *-1 mapping where files as disks are
           mapped into the ova and called out as disks in the
           generated ovf.
           The intent of the mapped sources is used to match with
           a desired capacity for the sources.  If intents are
           duplicated, i.e., two disk images supplied have
           the 'appliance' intent, then they will both receive
           the same capacity.  See flag disk-capacity-<intent>
    """
    # Takes: (UTCTime,)
    OVF_HEADER = """<?xml version="1.0" encoding="UTF-8"?>
<!--Generated by csmake, UTC time: %s-->"""

    # Takes: (A build id,)
    OVF_ENVELOPE_OPEN = """<Envelope vmw:buildId="%s" xmlns="http://schemas.dmtf.org/ovf/envelope/1" xmlns:cim="http://schemas.dmtf.org/wbem/wscim/1/common" xmlns:ovf="http://schemas.dmtf.org/ovf/envelope/1" xmlns:rasd="http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData" xmlns:vmw="http://www.vmware.com/schema/ovf" xmlns:vssd="http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_VirtualSystemSettingData" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">"""

    # OS disk format definitions for OVF
    # Reference:
    #  https://support.opennodecloud.com/wiki/doku.php?id=devdoc:os:ovf#disk_formats
    #   (with modifications for VMDK, per results of ovftool process
    #    and the virtual box export code)
    DISK_FORMATS = {
        "RAW": "http://raw",
        "QCOW2 Fixed Disk": "http://people.gnome.org/~markmc/qcow-image-format.html#monolithic_flat",
        "QCOW2 Sparse Disk": "http://people.gnome.org/~markmc/qcow-image-format.html#monolithic_sparse",
        "VMDK Stream Optimized": "http://www.vmware.com/interfaces/specifications/vmdk.html#streamOptimized",
        "VMDK Fixed Disk": "http://www.vmware.com/interfaces/specifications/vmdk.html#monolithic_flat",
        "VMDK Sparse Disk": "http://www.vmware.com/specifications/vmdk.html#sparse",
        "VDI Fixed Disk": "http://forums.virtualbox.org/viewtopic.php?t=8046#monolithic_flat",
        "VDI Sparse Disk": "http://forums.virtualbox.org/viewtopic.php?t=8046#monolithic_sparse",
        "VHD Fixed Disk": "http://technet.microsoft.com/en-us/virtualserver/bb676673.aspx#monolithic_flat",
        "VHD Sparse Disk": "http://technet.microsoft.com/en-us/virtualserver/bb676673.aspx#monolithic_sparse",
        "OpenVZ SimFS": "https://openvz.org/Man/vzctl.8",
        "OpenVZ Ploop": "http://openvz.org/Ploop",
    }

    # OS type definitions for OVF
    # Reference:
    #  :: NAMES :: (convention followed by vmware, kinda sorta)
    #  http://support.theenterprisecloud.com/kb/default.asp?SID=&Lang=1&id=1077
    #  :: IDS :: (The ovf standard id method)
    #  http://schemas.dmtf.org/wbem/cim-html/2/CIM_OperatingSystem.html
    OS_TYPES = {
        "Unknown" : ("Unknown", "Unknown", "0"),
        "AIX" : ("AIX", "AIX", "9"),
        "ASERIES" : ("ASERIES", "ASERIES", "32"),
        "ATTUNIX" : ("ATTUNIX", "ATTUNIX", "3"),
        "BS2000" : ("BS2000", "BS2000", "35"),
        "BSDUNIX" : ("BSDUNIX", "BSDUNIX", "41"),
        "BeOS" : ("BeOS", "BeOS", "53"),
        "Caldera Open UNIX" : ("Caldera Open UNIX", "Caldera Open UNIX", "64"),

        "asianux3" : ("asianux3Guest", "Asianux 3 (32-bit)", "36"),
        "asianux3_64" : ("asianux3_64Guest", "Asianux 3 (64-bit)", "101"),
        "asianux4" : ("asianux4Guest", "Asianux 4 (32-bit)", "36"),
        "asianux4_64" : ("asianux4_64Guest", "Asianux 4 (64-bit)", "101"),
        "centos" : ("centosGuest", "CentOS 4/5/6 (32-bit)", "106"),
        "centos64" : ("centos64Guest", "CentOS 4/5/6 (64-bit)", "107"),
        "darwin" : ("darwinGuest", "Apple Mac OS X 10.5 (32-bit)", "42"),
        "darwin10" : ("darwin10Guest", "Apple Mac OS X 10.6 (32-bit)", "42"),
        "darwin10_64" : ("darwin10_64Guest", "Apple Mac OS X 10.6 (64-bit)", "78"),
        "darwin11" : ("darwin11Guest", "Apple Mac OS X 10.7 (32-bit)", "42"),
        "darwin11_64" : ("darwin11_64Guest", "Apple Mac OS X 10.7 (64-bit)", "78"),
        "darwin64" : ("darwin64Guest", "Apple Mac OS X 10.5 (64-bit)", "78"),
        "DC/OS" : ("DC/OS", "DC/OS", "23"),
        "DECNT" : ("DECNT", "DECNT", "5"),

        "debian4" : ("debian4Guest", "Debian GNU/Linux 4 (32-bit)", "95"),
        "debian4_64" : ("debian4_64Guest", "Debian GNU/Linux 4 (64-bit)", "96"),
        "debian5" : ("debian5Guest", "Debian GNU/Linux 5 (32-bit)", "95"),
        "debian5_64" : ("debian5_64Guest", "Debian GNU/Linux 5 (64-bit)", "96"),
        "debian6" : ("debian6Guest", "Debian GNU/Linux 6 (32-bit)", "95"),
        "debian6_64" : ("debian6_64Guest", "Debian GNU/Linux 6 (64-bit)", "96"),
        "Dedicated" : ("Dedicated", "Dedicated", "59"),
        "DGUX" : ("DGUX", "DGUX", "4"),
        "dos" : ("dosGuest", "Microsoft MS-DOS", "14"),
        "eComStation" : ("eComStationGuest", "Serenity Systems eComStation 1", "110"),
        "eComStation2" : ("eComStation2Guest", "Serenity Systems eComStation 2", "110"),
        "EPOC" : ("EPOC", "EPOC", "49"),
        "freebsd" : ("freebsdGuest", "FreeBSD (32-bit)", "42"),
        "freebsd64" : ("freebsd64Guest", "FreeBSD (64-bit)", "78"),
        "GNU Hurd" : ("GNU Hurd", "GNU Hurd", "44"),
        "HP MPE" : ("HP MPE", "HP MPE", "54"),
        "HP NonStop OS" : ("HP NonStop OS", "HP NonStop OS", "33"),
        "HP NonStop OSS" : ("HP NonStop OSS", "HP NonStop OSS", "34"),
        "HPUX" : ("HPUX", "HPUX", "8"),
        "IRIX" : ("IRIX", "IRIX", "28"),
        "Inferno" : ("Inferno", "Inferno", "47"),
        "Interactive UNIX" : ("Interactive UNIX", "Interactive UNIX", "40"),
        "IxWorks" : ("IxWorks", "IxWorks", "50"),
        "JavaVM" : ("JavaVM", "JavaVM", "13"),
        "MACH Kernel" : ("MACH Kernel", "MACH Kernel", "46"),
        "MACOS" : ("MACOS", "MACOS", "2"),
        "MVS" : ("MVS", "MVS", "10"),
        "Mandriva" : ("Mandriva", "Mandriva", "89"),
        "Mandriva 64-Bit" : ("Mandriva 64-Bit", "Mandriva 64-Bit", "90"),
        "MiNT" : ("MiNT", "MiNT", "52"),
        "NCR3000" : ("NCR3000", "NCR3000", "20"),
        "NetBSD" : ("NetBSD", "NetBSD", "43"),
        "NetWare" : ("NetWare", "NetWare", "21"),
        "NextStep" : ("NextStep", "NextStep", "55"),
        "Not Applicable" : ("Not Applicable", "Not Applicable", "66"),
        "Novell Linux Desktop" : ("Novell Linux Desktop", "Novell Linux Desktop", "87"),
        "netware5" : ("netware5Guest", "Novell NetWare 5.1", "21"),
        "netware6" : ("netware6Guest", "Novell NetWare 6.x", "21"),
        "oes" : ("oesGuest", "Novell Open Enterprise Server", "86"),
        "openServer5" : ("openServer5Guest", "SCO OpenServer 5", "26"),
        "openServer6" : ("openServer6Guest", "SCO OpenServer 6", "26"),
        "oracleLinux" : ("oracleLinuxGuest", "Oracle Linux 4/5/6 (32-bit)", "108"),
        "oracleLinux64" : ("oracleLinux64Guest", "Oracle Linux 4/5/6 (64-bit)", "!09"),
        "os2" : ("os2Guest", "IBM OS/2", "12"),
        "OS/390" : ("OS/390", "OS/390", "60"),
        "OS400" : ("OS400", "OS400", "11"),
        "OS9" : ("OS9", "OS9", "45"),
        "OSF" : ("OSF", "OSF", "22"),
        "OpenBSD" : ("OpenBSD", "OpenBSD", "65"),
        "OpenVMS" : ("OpenVMS", "OpenVMS", "7"),
        "Oracle Linux 32-bit" : ("Oracle Linux 32-bit", "Oracle Linux 32-bit", "108"),
        "Oracle Linux 64-bit" : ("Oracle Linux 64-bit", "Oracle Linux 64-bit", "109"),
        "other" : ("otherGuest", "Other (32-bit)", "1"),
        "other24xLinux" : ("other24xLinuxGuest", "Other 2.4.x Linux (32-bit)", "97"),
        "other24xLinux64" : ("other24xLinux64Guest", "Other 2.4.x Linux (64-bit)", "98"),
        "other26xLinux" : ("other26xLinuxGuest", "Other 2.6.x Linux (32-bit)", "99"),
        "other26xLinux64" : ("other26xLinux64Guest", "Other 2.6.x Linux (64-bit)", "101"),
        "otherGuest64" : ("otherGuest64", "Other (64-bit)", "102"),
        "otherLinux" : ("otherLinuxGuest", "Other Linux (32-bit)", "36"),
        "otherLinux64" : ("otherLinux64Guest", "Other Linux (64-bit)", "101"),
        "PalmPilot" : ("PalmPilot", "PalmPilot", "56"),
        "QNX" : ("QNX", "QNX", "48"),
        "rhel2" : ("rhel2Guest", "Red Hat Enterprise Linux 2.1", "79"),
        "rhel3" : ("rhel3Guest", "Red Hat Enterprise Linux 3 (32-bit)", "79"),
        "rhel3_64" : ("rhel3_64Guest", "Red Hat Enterprise Linux 3 (64-bit)", "80"),
        "rhel4" : ("rhel4Guest", "Red Hat Enterprise Linux 4 (32-bit)", "79"),
        "rhel4_64" : ("rhel4_64Guest", "Red Hat Enterprise Linux 4 (64-bit)", "80"),
        "rhel5" : ("rhel5Guest", "Red Hat Enterprise Linux 5 (32-bit)", "79"),
        "rhel5_64" : ("rhel5_64Guest", "Red Hat Enterprise Linux 5 (64-bit)", "80"),
        "rhel6" : ("rhel6Guest", "Red Hat Enterprise Linux 6 (32-bit)", "79"),
        "rhel6_64" : ("rhel6_64Guest", "Red Hat Enterprise Linux 6 (64-bit)", "80"),
        "Sequent" : ("Sequent", "Sequent", "27"),
        "sles" : ("slesGuest", "SUSE Linux Enterprise 8/9 (32-bit)", "84"),
        "sles10" : ("sles10Guest", "SUSE Linux Enterprise 10 (32-bit)", "84"),
        "sles10_64" : ("sles10_64Guest", "SUSE Linux Enterprise 10 (64-bit)", "85"),
        "sles11" : ("sles11Guest", "SUSE Linux Enterprise 11 (32-bit)", "84"),
        "sles11_64" : ("sles11_64Guest", "SUSE Linux Enterprise 11 (64-bit)", "85"),
        "sles64" : ("sles64Guest", "SUSE Linux Enterprise 8/9 (64-bit)", "85"),
        "solaris10" : ("solaris10Guest", "Oracle Solaris 10 (32-bit)", "29"),
        "solaris10_64" : ("solaris10_64Guest", "Oracle Solaris 10 (64-bit)", "81"),
        "solaris11_64" : ("solaris11_64Guest", "Oracle Solaris 11 (64-bit)", "81"),
        "solaris8" : ("solaris8Guest", "Sun Microsystems Solaris 8", "29"),
        "solaris9" : ("solaris9Guest", "Sun Microsystems Solaris 9", "29"),
        "SUSE" : ("SUSE", "SUSE", "82"),
        "SUSE 64-Bit" : ("SUSE 64-Bit", "SUSE 64-Bit", "83"),
        "Sun Java Desktop System" : ("Sun Java Desktop System", "Sun Java Desktop System", "88"),
        "SunOS" : ("SunOS", "SunOS", "30"),
        "TPF" : ("TPF", "TPF", "62"),
        "Tru64 UNIX" : ("Tru64 UNIX", "Tru64 UNIX", "6"),
        "TurboLinux" : ("TurboLinux", "TurboLinux", "91"),
        "TurboLinux 64-Bit" : ("TurboLinux 64-Bit", "TurboLinux 64-Bit", "92"),
        "U6000" : ("U6000", "U6000", "31"),
        "ubuntu" : ("ubuntuGuest", "Ubuntu Linux (32-bit)", "93"),
        "ubuntu64" : ("ubuntu64Guest", "Ubuntu Linux (64-bit)", "94"),
        "unixWare7" : ("unixWare7Guest", "SCO UnixWare 7", "25"),
        "vmkernel" : ("vmkernelGuest", "VMware ESX 4.x", "104"),
        "vmkernel5" : ("vmkernel5Guest", "VMware ESXi 5.x", "104"),
        "VM" : ("VM", "VM", "39"),
        "VMware ESXi" : ("VMware ESXi", "VMware ESXi", "104"),
        "VSE" : ("VSE", "VSE", "61"),
        "VxWorks" : ("VxWorks", "VxWorks", "51"),
        "win2000AdvServ" : ("win2000AdvServGuest", "Microsoft Windows 2000", "58"),
        "win2000Pro" : ("win2000ProGuest", "Microsoft Windows 2000 Professional", "58"),
        "win2000Serv" : ("win2000ServGuest", "Microsoft Windows 2000 Server", "58"),
        "win31" : ("win31Guest", "Microsoft Windows 3.1", "15"),
        "win95" : ("win95Guest", "Microsoft Windows 95", "16"),
        "win98" : ("win98Guest", "Microsoft Windows 98", "17"),
        "winLonghorn" : ("winLonghornGuest", "Microsoft Windows Server 2008 (32-bit)", "76"),
        "winLonghorn64" : ("winLonghorn64Guest", "Microsoft Windows Server 2008 (64-bit)", "77"),
        "winNT" : ("winNTGuest", "Microsoft Windows NT", "18"),
        "winNetBusiness" : ("winNetBusinessGuest", "Microsoft Small Business Server 2003", "69"),
        "winNetDatacenter" : ("winNetDatacenterGuest", "Microsoft Windows Server 2003 Datacenter (32-bit)", "69"),
        "winNetDatacenter64" : ("winNetDatacenter64Guest", "Microsoft Windows Server 2003 Datacenter (64-bit)", "70"),
        "winNetEnterprise" : ("winNetEnterpriseGuest", "Microsoft Windows Server 2003 (32-bit)", "69"),
        "winNetEnterprise64" : ("winNetEnterprise64Guest", "Microsoft Windows Server 2003 (64-bit)", "70"),
        "winNetStandard" : ("winNetStandardGuest", "Microsoft Windows Server 2003 Standard (32-bit)",),
        "winNetStandard64" : ("winNetStandard64Guest", "Microsoft Windows Server 2003 Standard (64-bit)",),
        "winNetWeb" : ("winNetWebGuest", "Microsoft Windows Server 2003 Web Edition (32-bit)", "69"),
        "winVista" : ("winVistaGuest", "Microsoft Windows Vista (32-bit)", "73"),
        "winVista64" : ("winVista64Guest", "Microsoft Windows Vista (64-bit)", "74"),
        "winXPPro" : ("winXPProGuest", "Microsoft Windows XP Professional (32-bit)", "67"),
        "winXPPro64" : ("winXPPro64Guest", "Microsoft Windows XP Professional (64-bit)", "71"),
        "windows7" : ("windows7Guest", "Microsoft Windows 7 (32-bit)", "105"),
        "windows7Server64" : ("windows7Server64Guest", "Microsoft Windows Server 2008 R2 (64-bit)", "103"),
        "windows7_64" : ("windows7_64Guest", "Microsoft Windows 7 (64-bit)", "105"),
        "windows8" : ("windows8Guest", "Microsoft Windows 8 (32-bit)", "114"),
        "windows8Server64" : ("windows8Server64Guest", "Microsoft Windows Server 2012 (64-bit)", "113"),
        "windows8_64" : ("windows8_64Guest", "Microsoft Windows 8 (64-bit)", "115"),
        "Windows (R) Me" : ("Windows (R) Me", "Windows (R) Me", "63"),
        "XENIX" : ("XENIX", "XENIX", "38"),
        "z/OS" : ("z/OS", "z/OS", "68")
    }

    def _getUTCNowISODateTime(self):
        return datetime.datetime.utcnow().isoformat() + 'Z'

    def _getFileInfoNowTime(self):
        return int(time.mktime(
            datetime.datetime.now().timetuple()))

    def _generateFileReferences(self, disks):
        fileids = 'file%d'
        diskids = 'disk%d'
        resultxml = ['<References>']
        for index, disk in enumerate(disks):
            reference = fileids % (index + 1)
            path, vmdkfile = os.path.split(disk['location'])
            vmdkfilename, ext = os.path.splitext(vmdkfile)
            vmdkfile = "%s-%s%s" % (
                vmdkfilename,
                diskids % (index + 1),
                ext)
            disk['archivename'] = vmdkfile
            resultxml.append(
                '  <File ovf:href="%s" ovf:id="%s" ovf:size="%d"/>' % (
                    vmdkfile,
                    reference,
                    os.path.getsize(disk['location'])))
            disk['ova-reference'] = reference
        resultxml.append('</References>')
        return resultxml

    def _generateDiskSections(self, disks):
        diskids = 'vmdisk%d'
        resultxml = ['<DiskSection>', '  <Info>Virtual disk information</Info>']
        # Assumes VMDK format
        for index, disk in enumerate(disks):
            diskReference = diskids % (index + 1)
            disk['ova-diskid'] = diskReference
            reference = disk['ova-reference']
            capacityKey = 'disk-capacity-%s' % disk['intent']
            formatKey = 'disk-format-%s' % disk['intent']
            capacity = None
            if capacityKey in self.options:
                capacity = self.options[capacityKey].rstrip('G')
            else:
                self.log.error("A disk was mapped to the vm, but doesn't have a capacity associated with its intent")
                self.log.error("  looking for: %s=<capacity>G in the step specification", capacityKey)
                self.log.failed()
                raise KeyError(capacityKey)
            if formatKey in self.options:
                try:
                    diskFormat = CreateOVA.DISK_FORMATS[self.options[formatKey].strip()]
                except KeyError as e:
                    self.log.exception("The given format '%s' is unknown. valid formats are:", self.options[formatKey])
                    for key in CreateOVA.DISK_FORMATS.keys():
                        self.log.error(key)
                    self.log.failed()
                    raise e
            else:
                self.log.error("A disk was mapped to the vm, but doesn't have a format associated with its intent")
                self.log.error("  looking for: %s=<format> in the step specification", formatKey)
                self.log.failed()
                raise KeyError(capacityKey)
            if 'used-size' in disk:
                usedSize = ' ovf:populatedSize="%d"' % disk['used-size']
            else:
                usedSize = ''
                self.log.warning("The populatedSize field for the disk was not calculated   -   This information may be placed in the index as the used-size axis for the disk if it is known")
            resultxml.append(
                '  <Disk ovf:capacity="%s" ovf:capacityAllocationUnits="byte * 2^30" ovf:diskId="%s" ovf:fileRef="%s" ovf:format="%s"%s/>' % (
                capacity,
                diskReference,
                reference,
                diskFormat,
                usedSize))
        resultxml.append('</DiskSection>')
        return resultxml

    def _generateProductSection(self):
        metadata = self.metadata._getMetadataDefinitions()
        resultxml = ['<ProductSection>',
            '  <Info>Information about the installed software</Info>',
            '  <Product>%s</Product>' % self.options['vm-name'],
            '  <Vendor>%s</Vendor>' % metadata['manufacturer'],
            '  <Version>%s</Version>' % self.metadata._getDefaultDefinedVersion(),
            '</ProductSection>']
        return resultxml

    def _generateOperatingSystemSection(self):
        try:
            osid = CreateOVA.OS_TYPES[self.options['os']]
        except KeyError as e:
            self.log.exception("'%s' is an unknown OS.  Valid OS's are:", self.options['os'])
            for key, values in CreateOVA.OS_TYPES.iteritems():
                self.log.error("%s: %s", key, values[1])
            self.log.failed()
            raise e
        resultxml = ['<OperatingSystemSection ovf:id="%s" vmw.osType="%s">' % (
                      osid[2],
                      osid[0]) ]
        if 'os-description' in self.options:
            desc = self.options['os-description']
        else:
            desc = osid[1]
        resultxml.append('  <Info>The kind of installed guest operating system</Info>')
        resultxml.append('</OperatingSystemSection>')
        return resultxml

    def _generateProcessors(self, instanceId):
        numCpus = self.options['vm-cpus']
        resultxml = [
            '<Item>',
            '  <rasd:AllocationUnits>hertz * 10^6</rasd:AllocationUnits>',
            '  <rasd:Description>Number of Virtual CPUs</rasd:Description>',
            '  <rasd:ElementName>%s virtual CPU(s)</rasd:ElementName>' % numCpus,
            '  <rasd:InstanceID>%s</rasd:InstanceID>' % instanceId,
            '  <rasd:ResourceType>3</rasd:ResourceType>',
            '  <rasd:VirtualQuantity>%s</rasd:VirtualQuantity>' % numCpus,
            '</Item>' ]
        return resultxml

    def _generateMemory(self, instanceId):
        memAmount = self.options['vm-memory']
        resultxml = [
            '<Item>',
            '  <rasd:AllocationUnits>byte * 2^20</rasd:AllocationUnits>',
            '  <rasd:Description>Memory Size</rasd:Description>',
            '  <rasd:ElementName>%sMB of memory</rasd:ElementName>' % memAmount,
            '  <rasd:InstanceID>%s</rasd:InstanceID>' % instanceId,
            '  <rasd:Reservation>%s</rasd:Reservation>' % memAmount,
            '  <rasd:ResourceType>4</rasd:ResourceType>',
            '  <rasd:VirtualQuantity>%s</rasd:VirtualQuantity>' % memAmount,
            '</Item>' ]
        return resultxml

    def _generateSCSIController(self, address, instanceId):
        # NOTE: The address is *not* the SCSI id, it's the pci slot
        #      The instance id is also not the SCSI id...
        #      Presuming the SCSI id is 7 (traditionally), but don't know
        resultxml = [
          '<Item>',
          '  <rasd:Address>%s</rasd:Address>' % address,
          '  <rasd:Description>SCSI Controller</rasd:Description>',
          '  <rasd:ElementName>SCSI Controller 0</rasd:ElementName>',
          '  <rasd:InstanceID>%s</rasd:InstanceID>' % instanceId,
          '  <rasd:ResourceSubType>lsilogic</rasd:ResourceSubType>',
          '  <rasd:ResourceType>6</rasd:ResourceType>',
          '</Item>' ]
        return resultxml

    def _generateIDEController(self, address, instanceId):
        resultxml = [
          '<Item>',
          '  <rasd:Address>%s</rasd:Address>' % address,
          '  <rasd:Description>IDE Controller</rasd:Description>',
          '  <rasd:ElementName>VirtualIDEController %s</rasd:ElementName>' % address,
          '  <rasd:InstanceID>%s</rasd:InstanceID>' % instanceId,
          '  <rasd:ResourceType>5</rasd:ResourceType>',
          '</Item>' ]
        return resultxml

    def _generateVideoCard(self, instanceId):
        resultxml = [
            '<Item ovf:required="false">',
            '  <rasd:AutomaticAllocation>false</rasd:AutomaticAllocation>',
            '  <rasd:ElementName>VirtualVideoCard</rasd:ElementName>',
            '  <rasd:InstanceID>%s</rasd:InstanceID>' % instanceId,
            '  <rasd:ResourceType>24</rasd:ResourceType>',
            '  <vmw:Config ovf:required="false" vmw:key="enable3DSupport" vmw:value="false"/>',
            '  <vmw:Config ovf:required="false" vmw:key="enableMPTSupport" vmw:value="false"/>',
            '  <vmw:Config ovf:required="false" vmw:key="use3dRenderer" vmw:value="automatic"/>',
            '  <vmw:Config ovf:required="false" vmw:key="useAutoDetect" vmw:value="false"/>',
            '  <vmw:Config ovf:required="false" vmw:key="videoRamSizeInKB" vmw:value="4096"/>',
            '</Item>' ]
        return resultxml

    def _generateVMCIDevice(self, instanceId):
        resultxml = [
          '<Item ovf:required="false">',
          '  <rasd:AutomaticAllocation>false</rasd:AutomaticAllocation>',
          '  <rasd:ElementName>VirtualVMCIDevice</rasd:ElementName>',
          '  <rasd:InstanceID>%s</rasd:InstanceID>' % instanceId,
          '  <rasd:ResourceSubType>vmware.vmci</rasd:ResourceSubType>',
          '  <rasd:ResourceType>1</rasd:ResourceType>',
          '  <vmw:Config ovf:required="false" vmw:key="allowUnrestrictedCommunication" vmw:value="false"/>',
          '</Item>' ]
        return resultxml

    def _generateDiskDevice(self, instanceId, diskId, address, parentId):
        # NOTE: The address *is* the SCSI id for scsi hard drives
        resultxml = [
          '<Item>',
          '  <rasd:AddressOnParent>%s</rasd:AddressOnParent>' % address,
          '  <rasd:ElementName>Hard Disk %s</rasd:ElementName>' % diskId.lstrip('vmdisk'),
          '  <rasd:HostResource>ovf:/disk/%s</rasd:HostResource>' % diskId,
          '  <rasd:InstanceID>%s</rasd:InstanceID>' % instanceId,
          '  <rasd:Parent>%s</rasd:Parent>' % parentId,
          '  <rasd:ResourceType>17</rasd:ResourceType>',
          '  <vmw:Config ovf:required="false" vmw:key="backing.writeThrough" vmw:value="false"/>',
          '</Item>' ]
        return resultxml

    def _generateCDDVDDevice(self, instanceId, parentId):
          # If no AddressOnParent element is specified, devices are attached to their parent in
          # the order they're declared in the .ovf description.
        resultxml = [
          '<Item>',
          '  <rasd:AutomaticAllocation>false</rasd:AutomaticAllocation>',
          '  <rasd:ElementName>CD/DVD Drive 1</rasd:ElementName>',
          '  <rasd:InstanceID>%s</rasd:InstanceID>' % instanceId,
          '  <rasd:Parent>%s</rasd:Parent>' % parentId,
          '  <rasd:ResourceType>15</rasd:ResourceType>',
          '</Item>' ]
        return resultxml

    def _generateVirtualHardwareOptions(self):
        # TODO: Provide a way to specify options?
        #     in spec, for example:
        #         VMOptions =
        #             cpuHotAddEnabled: false
        #             cpuHotRemoveEnabled: false
        # And then, perhaps provide this list as the defaults in a dictionary?
        resultxml = [
          '<vmw:Config ovf:required="false" vmw:key="cpuHotAddEnabled" vmw:value="false"/>',
          '<vmw:Config ovf:required="false" vmw:key="cpuHotRemoveEnabled" vmw:value="false"/>',
          '<vmw:Config ovf:required="false" vmw:key="firmware" vmw:value="bios"/>',
          '<vmw:Config ovf:required="false" vmw:key="virtualICH7MPresent" vmw:value="false"/>',
          '<vmw:Config ovf:required="false" vmw:key="virtualSMCPresent" vmw:value="false"/>',
          '<vmw:Config ovf:required="false" vmw:key="memoryHotAddEnabled" vmw:value="false"/>',
          '<vmw:Config ovf:required="false" vmw:key="nestedHVEnabled" vmw:value="false"/>',
          '<vmw:Config ovf:required="false" vmw:key="powerOpInfo.powerOffType" vmw:value="soft"/>',
          '<vmw:Config ovf:required="false" vmw:key="powerOpInfo.resetType" vmw:value="soft"/>',
          '<vmw:Config ovf:required="false" vmw:key="powerOpInfo.standbyAction" vmw:value="checkpoint"/>',
          '<vmw:Config ovf:required="false" vmw:key="powerOpInfo.suspendType" vmw:value="hard"/>',
          '<vmw:Config ovf:required="false" vmw:key="tools.afterPowerOn" vmw:value="true"/>',
          '<vmw:Config ovf:required="false" vmw:key="tools.afterResume" vmw:value="true"/>',
          '<vmw:Config ovf:required="false" vmw:key="tools.beforeGuestShutdown" vmw:value="true"/>',
          '<vmw:Config ovf:required="false" vmw:key="tools.beforeGuestStandby" vmw:value="true"/>',
          '<vmw:Config ovf:required="false" vmw:key="tools.syncTimeWithHost" vmw:value="false"/>',
          '<vmw:Config ovf:required="false" vmw:key="tools.toolsUpgradePolicy" vmw:value="manual"/>',
          '<vmw:ExtraConfig ovf:required="false" vmw:key="disk.enableUUID" vmw:value="true"/>'
        ]
        return resultxml

    def _generateVirtualHardware(self, vmId, disks):
        instanceId = 1
        resultxml = [
            '<VirtualHardwareSection>',
            '  <Info>Virtual hardware requirements</Info>',
            '  <System>',
            '    <vssd:ElementName>Virtual Hardware Family</vssd:ElementName>',
            '    <vssd:InstanceID>0</vssd:InstanceID>',
            '    <vssd:VirtualSystemIdentifier>%s</vssd:VirtualSystemIdentifier>' % vmId,
            '    <vssd:VirtualSystemType>vmx-09</vssd:VirtualSystemType>',
            '  </System>' ]
        self._appendXml(2, resultxml, self._generateProcessors(instanceId))
        instanceId += 1
        self._appendXml(2, resultxml, self._generateMemory(instanceId))
        instanceId += 1
        self._appendXml(2, resultxml, self._generateSCSIController(0, instanceId))
        diskParent = instanceId
        instanceId += 1
        # We cannot simply remove IDE controllers since we need a virtual CD/DVD, but we only need one controller.
        self._appendXml(2, resultxml, self._generateIDEController(0, instanceId))
        ideControllerId = instanceId  # save IDE controller Id for use by CD/DVD device (below)
        instanceId += 1
        self._appendXml(2, resultxml, self._generateVideoCard(instanceId))
        instanceId += 1
        self._appendXml(2, resultxml, self._generateVMCIDevice(instanceId))
        instanceId += 1
        # NOTE: This puts all hard disks on the same controller
        #      What address is the controller on?  7?  Hmmm
        #      Not attempting to handle the case where there might be a
        #      conflict between the initiator and the disk for ids
        for address, disk in enumerate(disks):
            self._appendXml(2, resultxml, self._generateDiskDevice(instanceId, disk['ova-diskid'], address, diskParent))
            instanceId += 1
        # Add CD/DVD Drive if desired
        if 'add-cd-dvd-rom' in self.options and 'True' == self.options['add-cd-dvd-rom']:
            self._appendXml(2, resultxml, self._generateCDDVDDevice(instanceId, ideControllerId))
        self._appendXml(2, resultxml, self._generateVirtualHardwareOptions())
        resultxml.append("</VirtualHardwareSection>")
        return resultxml

    def _generateVirtualSystem(self, disks):
        vmId = self.options['vm-name']
        resultxml = ['<VirtualSystem ovf:id="%s">' % vmId]
        resultxml.append('    <Info>A virtual machine</Info>')
        resultxml.append('    <Name>%s</Name>' % vmId)
        self._appendXml(2, resultxml, self._generateOperatingSystemSection())
        self._appendXml(2, resultxml, self._generateVirtualHardware(vmId, disks))
        self._appendXml(2, resultxml, self._generateProductSection())
        resultxml.append('</VirtualSystem>')
        return resultxml

    def _appendXml(self, indent, resultxml, newxml):
        for line in newxml:
            resultxml.append((' ' * indent) + line)

    def _generateOVF(self, disks):
        resultxml = [
            CreateOVA.OVF_HEADER % self._getUTCNowISODateTime(),
            CreateOVA.OVF_ENVELOPE_OPEN % 'build-2500155' ]
        xml = self._generateFileReferences(disks)
        self._appendXml(2, resultxml, xml)
        xml = self._generateDiskSections(disks)
        self._appendXml(2, resultxml, xml)
        xml = self._generateVirtualSystem(disks)
        self._appendXml(2, resultxml, xml)
        resultxml.append('</Envelope>                   ')
        return resultxml

    def _tarFilter(self, info):
        info.mtime = self._getFileInfoNowTime()
        info.mode = 420
        info.uid = 64
        info.gid = 64
        info.uname = 'someone'
        info.gname = 'someone'
        return info

    def _makeManifestForFile(self, fileobj, filename):
        digest = self._fileDigest(
            self.digestFormat,
            fileobj)
        return "%s(%s)= %s" % (
            self.digestFormatString,
            filename,
            digest)

    def build(self, options):
        self.options = options
        self.digestFormat = hashlib.sha1
        self.digestFormatString = "SHA1"
        if 'manifest-format' in options:
            fmat = options['manifest-format'].lower()
            if fmat == 'sha1':
                pass
            elif fmat == 'sha256':
                self.digestFormat = hashlib.sha256
                self.digestFormatString = "SHA256"
            else:
                self.log.error("Unknown 'manifest-format': %s", fmat)
                self.log.failed()
                return None

        # For each mapping specified create a new archive
        for froms, tos in self.mapping.iterspecs():

            # The generation process will add extra information
            #  to the file indicies for each disk file
            ovflines = self._generateOVF(froms)

            # It is assumed right now that mapping set only maps to a single
            #  archive - i.e. 1-1 or *-1
            ovapath = tos[0]['location']

            # Create the ova archive.  Files from vmware are USTAR format.
            with tarfile.open(ovapath, 'w', format=tarfile.USTAR_FORMAT) as outova:
                dirname, ovafilename = os.path.split(ovapath)
                namepart, extpart = os.path.splitext(ovafilename)

                # Write the ovf to the tar
                buf = '\n'.join(ovflines)
                ovffile = StringIO.StringIO(buf)
                ovffilename = "%s.ovf" % namepart
                mflines = []
                mflines.append(self._makeManifestForFile(ovffile, ovffilename))
                fileinfo = tarfile.TarInfo(ovffilename)
                fileinfo.size = len(buf)
                fileinfo = self._tarFilter(fileinfo)
                outova.addfile(fileinfo, ovffile)

                # Add all the disks
                for index, fromfile in enumerate(froms):
                    fromlocation = fromfile['location']
                    fromlocationFilename = fromfile['archivename']
                    sha1 = None
                    with open(fromlocation, 'rb') as diskfile:
                        mflines.append(self._makeManifestForFile(
                                           diskfile,
                                           fromlocationFilename))
                    # Add the actual disk
                    outova.add(
                        name=fromlocation,
                        arcname=fromlocationFilename,
                        filter=self._tarFilter)

                # Add the manifest
                buf = '\n'.join(mflines) + '\n'
                mffile = StringIO.StringIO(buf)
                fileinfo = tarfile.TarInfo("%s.mf" % namepart)
                fileinfo.size = len(buf)
                fileinfo = self._tarFilter(fileinfo)
                outova.addfile(fileinfo, mffile)

        self.log.passed()

    def clean(self, options):
        self.log.passed()
        pass
